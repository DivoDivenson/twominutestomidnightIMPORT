{\rtf1\ansi\ansicpg1252\deff0
{\fonttbl
{\f0\fnil\fcharset0\fprq0\fttruetype Times New Roman;}
{\f1\fnil\fcharset0\fprq0\fttruetype Liberation Sans;}
{\f2\fnil\fcharset0\fprq0\fttruetype Dingbats;}
{\f3\fnil\fcharset0\fprq0\fttruetype Symbol;}
{\f4\fnil\fcharset0\fprq0\fttruetype Courier New;}}
{\colortbl
\red0\green0\blue0;
\red255\green255\blue255;}
{\stylesheet
{\s1\fi-431\li720\sbasedon29\snext29Contents 1;}
{\s2\fi-431\li1440\sbasedon29\snext29Contents 2;}
{\s3\fi-431\li2160\sbasedon29\snext29Contents 3;}
{\s8\fi-431\li720\sbasedon29Lower Roman List;}
{\s5\tx431\sbasedon25\snext29Numbered Heading 1;}
{\s6\tx431\sbasedon26\snext29Numbered Heading 2;}
{\s7\fi-431\li720Square List;}
{\*\cs11\sbasedon29Endnote Text;}
{\s4\fi-431\li2880\sbasedon29\snext29Contents 4;}
{\s9\fi-431\li720Diamond List;}
{\s10\fi-431\li720Numbered List;}
{\*\cs12\fs20\superEndnote Reference;}
{\s13\fi-431\li720Triangle List;}
{\s14\tx431\sbasedon27\snext29Numbered Heading 3;}
{\s15\fi-431\li720Dashed List;}
{\s16\fi-431\li720\sbasedon10Upper Roman List;}
{\s17\sb440\sa60\f1\fs24\b\sbasedon29\snext29Heading 4;}
{\s18\fi-431\li720Heart List;}
{\s35\fi-431\li720Box List;}
{\*\cs20\fs20Reference;}
{\s21\fi-431\li720\sbasedon10Upper Case List;}
{\s22\fi-431\li720Bullet List;}
{\s23\fi-431\li720Hand List;}
{\*\cs24\fs20\sbasedon29Footnote Text;}
{\s25\sb440\sa60\f1\fs34\b\sbasedon29\snext29Heading 1;}
{\s26\sb440\sa60\f1\fs28\b\sbasedon29\snext29Heading 2;}
{\s19\qc\sb240\sa120\f1\fs32\b\sbasedon29\snext29Contents Header;}
{\s28\fi-431\li720Tick List;}
{\s27\sb440\sa60\f1\fs24\b\sbasedon29\snext29Heading 3;}
{\s30\fi-431\li720\sbasedon10Lower Case List;}
{\s31\li1440\ri1440\sa120\sbasedon29Block Text;}
{\s37\f4\sbasedon29Plain Text;}
{\s33\tx1584\sbasedon5\snext29Section Heading;}
{\s34\fi-431\li720Implies List;}
{\s29\f0\fs24Normal;}
{\s36\fi-431\li720Star List;}
{\*\cs32\fs20\superFootnote Reference;}
{\s38\tx1584\sbasedon5\snext29Chapter Heading;}}
{\*\listtable
{\list\listtemplateid1062\listsimple{\listlevel\levelnfc0\levelstartat1\levelspace0\levelfollow0\fi-431\li720{\leveltext\'02\'00.;}{\levelnumbers\'01;}}\listid1002}}
{\*\listoverridetable
{\listoverride\listoverridecount0\listid1002\levelnfc0\levelstartat1\levelspace0\levelfollow0\fi-431\li720{\leveltext\'02\'00.;}{\levelnumbers\'01;}\ls1}}

\kerning0\cf0\ftnbj\fet2\ftnstart1\ftnnar\aftnnar\ftnstart1\aftnstart1\aenddoc\revprop3{\info\uc1}\deftab720\viewkind1\paperw11905\paperh16837\margl1440\margr1440\widowctrl
\sectd\sbknone\colsx360\pgncont\ltrsect
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch CS2041 Information management}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Serial File}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Steven Diviney}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch 08462267}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch The program consists of six classes. Main which contains a short demo,  Record which is used to store a record read off disc, SerialFileRandom which handles the I/O and three comparator classes.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Functionality:}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab SerialFileRandom;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab SerialFileRandom comes in two flavours. One which requires a file name and record delimiters as arguments and one which requires a file name only. The one argument constructor simply calls the other with default values for the delimiters.  SerialFileRandom handles the usual initialization stuff. It creates a FileReader and BufferdReader. It also creates and empty ArrayList of records. Once the file is open it class readIn() and closes the file streams as the file no longer needs to be read.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab readIn ;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Reads the file in using a BufferdReader. It reads a line, parses it for fields and creates a new Record object which represents the record read in.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab parse;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Given a field name and an input string parse extracts and returns the field value. It uses a simple Pattern object to do this. If the given pattern is not found, the file is presumed to be corrupt. The user is receives an error and an IllegalStateException is passed to handlException.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab handleException;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Takes in any Throwable object as a parameter. It simply prints the error and exits the program, returning a 1 to indicate error.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab writeOut;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Rights the currents representation of the file out to the file. It rewrites the whole file. I implemented it this way because I had difficulty getting a RandomAccessFile to work. More on that later. The method creates a new File and Print Writer, prints the array of records out and closes the writers.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab printRecord;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Takes the ID of the record as a paramater. It uses a simple for-each loop to find the record and returns a string representation of it. It will not return a deleted record.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab deleteRecord;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Takes the ID as a paramater. Again, a simple for-each loop is used to find the record. The delete flag is then set and writeOut is called.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Another variation takes in field name and value to find the record. This simply calls searchRecord and passes the returned ID to deleteRecord(int).}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab searchRecord;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Takes in the field name and value and returns a single record ID. getField is used to convert the fieldname argument into an int. This is then used in a switch statement which calls the relevant findRecord method. 0 is returned if no record is found.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab findRecord}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Several variations, each consisting of a for each loop that searches for a record based on a specific field. Variations are:  }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
{\listtext\pard\fi-431\li720 1.	}\pard\plain{\ltrpar\ql\fi-431\li720\s29{\*\abilist\abilistid1002\abilistparentid0\abilistlevel1\abistartat1{\abifieldfont NULL}{\abilistdecimal .}{\abilistdelim %L.}{\abiliststyle Numbered List}}{\*\pn\pnql\pnstart1\pnlvlbody\pndec{\pntxtb }{\pntxta .}}\fn-431\li720\ls1\ilvl0\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch findRecord, search by ID.}{\s29\f0\fs24\lang2057{\*\listtag1003}\par}
}{\listtext\pard\fi-431\li720 2.	}\pard\plain{\ltrpar\ql\fi-431\li720\s29{\*\abilist\abilistid1002\abilistparentid0\abilistlevel1\abistartat1{\abifieldfont NULL}{\abilistdecimal .}{\abilistdelim %L.}{\abiliststyle Numbered List}}{\*\pn\pnql\pnstart1\pnlvlbody\pndec{\pntxtb }{\pntxta .}}\fn-431\li720\ls1\ilvl0\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch findRecordLN, search by last name }{\s29\f0\fs24\lang2057{\*\listtag0}lexicographically.}{\s29\f0\fs24\lang2057{\*\listtag1004}\par}
}{\listtext\pard\fi-431\li720 3.	}\pard\plain{\ltrpar\ql\fi-431\li720\s29{\*\abilist\abilistid1002\abilistparentid0\abilistlevel1\abistartat1{\abifieldfont NULL}{\abilistdecimal .}{\abilistdelim %L.}{\abiliststyle Numbered List}}{\*\pn\pnql\pnstart1\pnlvlbody\pndec{\pntxtb }{\pntxta .}}\fn-431\li720\ls1\ilvl0\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch findRecordFN, search by first name }{\s29\f0\fs24\lang2057{\*\listtag0}lexicographically.}{\s29\f0\fs24\lang2057{\*\listtag1012}\par}
}{\listtext\pard\fi-431\li720 4.	}\pard\plain{\ltrpar\ql\fi-431\li720\s29{\*\abilist\abilistid1002\abilistparentid0\abilistlevel1\abistartat1{\abifieldfont NULL}{\abilistdecimal .}{\abilistdelim %L.}{\abiliststyle Numbered List}}{\*\pn\pnql\pnstart1\pnlvlbody\pndec{\pntxtb }{\pntxta .}}\fn-431\li720\ls1\ilvl0\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch findRecirdPOS, search by position }{\s29\f0\fs24\lang2057{\*\listtag0}lexicographically.}{\s29\f0\fs24\lang2057{\*\listtag1024}\par}
}\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Did no implement search by deletion marker.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab getField;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Simply converts a field name to an int. ID = 1, LN = 2, FN = 3, POS = 0, X = 5. 0 is returned in all other cases.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab updateField;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Calls findRecord and uses the records set functions to change the supplied field. writeOut is called if the record is changed successfully. }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab addRecord;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Simply creates a new record object and stores it based on the input parameters. If the record is successfully created writeOut is called. }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab compress}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Searches through all the records, removing any that have the delete flag set. It the trims the ArrayList and calls write out.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab sort}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab Uses Collections sort method to sort the array by the field specified by the argument paramater fieldname. When sorting by ID, record's compareTo method is used. For the other field names one of three simple comparator objects are used. If sorting was successful writeOut is called.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab changeDelim;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab \tab \tab Calls change delim in each record. I chose to store the delimiters inside the record to simplify printing. In retrospect it was a poor decision.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Record;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab The record class is a simple data class with all the usual setters and getters. It also contains compareTo, equals and toString. changeDelim is discussed above.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Main;}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab Simply contains a demo of all the methods working.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch Functionality not implemented / Issues.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch I did not change the end of record delimiter (\\n). This would have involved overwriting BufferdReader's readLine() method and PrintWriter print(String) method to use different string terminating characters. }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch RandomAccessFile's standard write methods printed out lots of garbage. Presuming it was using the wrong character set I then tried writeUTF, but this writes out the size of the string its about to write out first. This would have made successive runs of the program difficult. Two readIn methods would be required, as well as some sort of preserved count of program executions.  Because of this I decided to just re-write the file completely each time.}{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch All other functionality was implemented as required.  }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch  }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\abinodiroverride\ltrch \tab }{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}
\pard\plain\ltrpar\qc\s29\itap0{\s29\f0\fs24\lang2057{\*\listtag0}\par}}
