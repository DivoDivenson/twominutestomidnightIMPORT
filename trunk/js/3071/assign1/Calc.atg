#include<stdio.h>
#include<map>
#include<string>
#include<iterator>
using namespace std;
COMPILER Calc

  map<string, int> * tab;

CHARACTERS
	digit = '0' .. '9'.
   letter = 'A'..'Z' + 'a'..'z'.
   hexDigit = digit + "ABCDEF".

TOKENS
  ident = letter {letter | digit}.
	number = digit{digit} | "0x" hexDigit {hexDigit}.

COMMENTS FROM "//" TO '\r' '\n'

IGNORE '\r' + '\n'

PRODUCTIONS
	Calc			(. int r; char *name; .)
	=
   {
    Ident<name> 
      ":="  
    Expr<r>     (. 
                    printf("%s is assigned %d\n", name, r);
                    tab->insert(pair<string, int>(name, r));
                 .)
                    //printf("%d", (tab->find(string(name))->second));.) second points to mapped value 
    }
    |
      
    "display" { Expr<r>
      [
        ":hex"  (. printf("0x%x\n", r); .)
      |
        ":oct"  (. printf("0%o\n", r); .)
      
                (. printf("%d\n", r); .)
      ]
    }
    .

  Ident<char* &name> //& used to specify output, and returning a string, hence the mad * &.
  =
  ident     (. name = coco_string_create_char(t->val); .)
  .
	/*-------------------------------------------------------*/	
   //I'm pretty sure this is the wrong way to do this
	Expr<int &n>		(. int n1; .)
	= Term<n>
	{  '+' Term<n1>		(. n = n + n1; .)
      | '-' Term<n1>      (. n = n * n1; .)
	}.

   /*-------------------------------------------------------*/
	Term<int &n>  (. int n2; .) //Simple way to build in precedence	
   =
   Factor<n>
   {  '*' Factor<n2> (. n =n * n2; .)
   }.

   Factor<int &n>    (. char *name; .)
   = number       (. swscanf(t->val, L"%d",&n);  .)
   | ident (.  //Look for the value in the map. If it's not there print an error
               map<string, int>::iterator it = tab->find(coco_string_create_char(t->val));
               if(it != tab->end()){
                  n = it->second;
               }else{
                  n = 0;
                  printf("Unknowen var\n");
               }
               .)
         
// | "(" Expr<n> ")" //Check if this works later
   .
	
   
END Calc.
